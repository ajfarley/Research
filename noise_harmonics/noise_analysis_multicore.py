#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Wed Jun 17 12:06:26 2020@author: abramfarley"""import pfioimport numpy as npfrom numpy import genfromtxtimport mathimport osimport sysimport matplotlib.pyplot as pltimport matplotlib.patches as mpatchesimport matplotlib.lines as mlinesimport matplotlib.cm as cmimport matplotlib as mplfrom scipy import pifrom scipy.fftpack import fftfrom scipy import fftpackfrom scipy import signalfrom scipy import integrateimport statisticsfrom statsmodels.graphics.tsaplots import plot_acfnp.set_printoptions(threshold=sys.maxsize)#%%#csv of the input signal (white noise)Signal = genfromtxt('/Users/abramfarley/ParF/uahpc/matching_inputs/over0.4freq_hn/noise_input_july.csv', delimiter=',')Signal = Signal[0:10000]print(Signal)#%%#simulations = {'slopex' : [0.02, 0.05, 0.08, 0.1, 0.15]}simulations = {'slopex' : [0.02, 0.05, 0.08, 0.1]}#simulations = {'slopex' : [0.02]}dx = 10    #dims a domain celldy = 10dz = 0.5z = 50X_Range_Long = list(range(0,10000)) #x values for plotting later#%%# Plotting the seriesplt.plot(X_Range_Long, Signal, marker='.', markersize=4)#plt.plot(irregular_tie_samples2, samples2, marker='o', markersize=4)plt.xlabel('Timestep')plt.ylabel('Magnitude')plt.title('input timeseries (Qin)');plt.savefig('wn_input.png')#%%### output path setting Porosity = pfio.pfread('/Users/abramfarley/ParF/uahpc/matching_inputs/spinups/spinup0.1/spinup0.1.out.porosity.pfb')nx = Porosity.shape[2]nz = Porosity.shape[0]ny = Porosity.shape[1]Slopey = 0.01Cell_Volume = dx*dy*dzMannings = 3*10**(-6)Spec_Stor = pfio.pfread('/Users/abramfarley/ParF/uahpc/matching_inputs/spinups/spinup0.1/spinup0.1.out.specific_storage.pfb')#%%## precip time seriesQin = []input = Signalfor i in range(len(Signal)):    area = dx*dy*nx*ny        #top layer surface area    precip = Signal[i] * area  #volumetric flux into domain    Qin.append(precip)        #%%plt.plot(Signal[0:1000])#%%surface_storage_dict = {}groundwater_storage = {}Qout_dict = {}outflow_dict = {}delta_S_dict = {}change_substorage_dict = {}change_sufstorage_dict = {}change_storage_actual = {}subsurface_storage = {}pressure_dict = {}saturation_dict = {}#storage_layered = {'slope0': {}, 'slope1': {}, 'slope2': {}, 'slope3': {}, 'slope4': {}}#storage_layered = {'slope0': {}, 'slope1': {}, 'slope2': {}}storage_layered = {'slope0': {}}wtd_dict = {}wtd_dict2 = {}WTD_TCL = {}average_wtd ={}for slope in range(len(simulations['slopex'])):    Sim_Num = simulations['slopex'][slope]    Slopex = []    for i in range(nx):           if i < 15:   #nx-1/2            Slopex.append(-1 * Sim_Num)   #left side has negative slope        elif i == 15:   #nx-1/2            Slopex.append(0.0)    #middle is the channel        else:            Slopex.append(Sim_Num)   #right side has postitive slope    print(Slopex)        surface_storage_dict['slope%s'%(slope)] = []    groundwater_storage['slope%s'%(slope)] = []    Qout_dict['slope%s'%(slope)] = []    outflow_dict['slope%s'%(slope)] = []    delta_S_dict['slope%s'%(slope)] = []    change_substorage_dict['slope%s'%(slope)] = []    change_sufstorage_dict['slope%s'%(slope)] = []    change_storage_actual['slope%s'%(slope)] = []    subsurface_storage['slope%s'%(slope)] = []    pressure_dict['slope%s'%(slope)] = []    saturation_dict['slope%s'%(slope)] = []    wtd_dict['slope%s'%(slope)] = []    average_wtd['slope%s'%(slope)] = []    wtd_dict2['slope%s'%(slope)] = []    WTD_TCL['slope%s'%(slope)] = []    storage_layered['slope%s'%(slope)] = {}    for layer in range(nz):        storage_layered['slope%s'%(slope)]['layer%s'%(layer)] = []        sbs_t = 0    surf_t = 0    Initial_Surf_Storage = None    #nothing assigned (will be filled or will be set to zero in conditional statment)    Initial_Subsurf_Storage = None #nothing assigned (will be filled or will be set to zero in conditional statment)    Sim_Num = simulations['slopex'][slope]    path = '/Users/abramfarley/ParF/uahpc/matching_inputs/over0.4freq_hn/noise_highfreq{}/noise_highfreq{}'.format(Sim_Num, Sim_Num)    #path2 = '/Users/abramfarley/ParF/uahpc/RK_ratios_dxdy10/RK_outputs_channelsx0_initialpfb/tilted_v_layered_initialpfb{}/'.format(Sim_Num)    for t in range(len(Signal)):        saturation = pfio.pfread(path + '.out.satur.{:05}.pfb'.format(t))        pressure = pfio.pfread(path + '.out.press.{:05}.pfb'.format(t))                #WTD_check = pfio.pfread(path2 + 'WTD.{:05}.pfb' .format(t))        #result = np.where(WTD_check<0, 5, WTD_check)        #WTD_TCL['slope%s'%(slope)].append(result)                pressure_dict['slope%s'%(slope)].append(pressure)        saturation_dict['slope%s'%(slope)].append(saturation)                  ###WTD CALC 1        wtd = np.zeros((ny,nx))        for x in range(nx):            for y in range(ny):                #if pressure_dict['slope%s'%(slope)][t][nz-1,y,x] <= 5:                wtd[y,x] = ((nz*dz)-dz/2) - pressure_dict['slope%s'%(slope)][t][0,y,x]                 if pressure_dict['slope%s'%(slope)][t][nz-1,y,x] > 0:                    wtd[y,x] = 0#                     print(slope, t, y, x,'water ponded')#                     wtd[y,x] = wtd[y,x] - pressure_dict['slope%s'%(slope)][t][nz-1,y,x]        wtd_dict['slope%s'%(slope)].append(wtd)                ###WTD CALC 2        wtd2 = np.zeros((ny,nx))        for x in range(nx):            for y in range(ny):                value_placed = False                for z in range(nz-1, -1, -1):    #start at the top and count down through the layers                    if saturation_dict['slope%s'%(slope)][t][z, y, x] == 1.0 and value_placed == False:                            #print(saturation_dict['slope%s'%(slope)][t][z, y, x])                        wtd2[y,x]=(nz*dz) - ((z)*dz) - dz                        value_placed = True                            #wtd[x,y]=(dz*nz)-((z-1)*dz)                    elif z == 0 and value_placed == False:                        wtd2[y,x]=(nz*dz)                           wtd_dict2['slope%s'%(slope)].append(wtd2)                #subsurface storage calculation        gws = (saturation == 1.0) * Cell_Volume *(Porosity + (pressure * Spec_Stor))        sbs = saturation*Cell_Volume*(Porosity + (pressure * Spec_Stor))            #initialize variables        temp_sbs = 0        total_gws = 0        temp_gws = 0        total_sbs = 0        Qout_x = 0        Qout_y = 0        outflow = 0        total_surface_storage = 0        temp_surface_storage = 0        surface_storage = []                for k in range(nz):            layer_sbs = 0            for j in range(ny):                for i in range(nx):                    cell_sbs = sbs[k,j,i]                    layer_sbs = layer_sbs + cell_sbs                    if j == ny - 1 and i == nx - 1:                        storage_layered['slope%s'%(slope)]['layer%s'%(k)].append(layer_sbs)        for i in range(nx):            for j in range(ny):                for k in range(nz):                                    temp_sbs = sbs[k,j,i]                    total_sbs = total_sbs + temp_sbs                                        temp_gws = gws[k,j,i]                    total_gws = total_gws + temp_gws                                        if t == 0:                        Initial_Subsurf_Storage = total_sbs                    if Initial_Subsurf_Storage is None:                        Initial_Subsurf_Storage = 0                                    if j == ny-1 and k == nz-1:   #if at the base of the v                        sfmag = ((Slopex[i])**2 + Slopey**2)**0.5                        outflow_t = ((max(pressure[k,j,i],0)**(5.0/3.0)) * Slopey / (sfmag ** 0.5) / Mannings) * dx                        Qy_t = (math.sqrt(abs(Slopey))/Mannings)*(max(pressure[k,j,i],0)**(5.0/3.0)) * dx                        Qout_y = Qout_y + Qy_t                        outflow = outflow + outflow_t                                             if k == nz - 1 and pressure[nz-1,j,i] > 0.0:                        temp_surface_storage = pressure[nz-1,j,i] * dx * dy                        total_surface_storage = total_surface_storage + temp_surface_storage                        if t == 0:                            Initial_Surf_Storage = total_surface_storage                                            if Initial_Surf_Storage is None:                        Initial_Surf_Storage = 0                        print('no water on top')                average_wtd['slope%s'%(slope)].append(np.mean(wtd_dict['slope%s'%(slope)][t]))                      surface_storage_dict['slope%s'%(slope)].append(total_surface_storage)                        delta_S = Qin[t] - outflow    #m3/day        delta_S_dict['slope%s'%(slope)].append(delta_S)        #surface_storage.append(total_surface_storage)        groundwater_storage['slope%s'%(slope)].append(total_gws)        Qout_tot = Qout_x + Qout_y        Qout_dict['slope%s'%(slope)].append(Qout_tot)        outflow_dict['slope%s'%(slope)].append(outflow)            #print((surface_storage))        subsurface_storage['slope%s'%(slope)].append(total_sbs)            #print(t,'subsurface storage:', int(total_sbs), 'surface storage is:', int(total_surface_storage), 'runoff', int(outflow))        if t == 0:            change_substorage = (total_sbs - Initial_Subsurf_Storage)   #divide my dt (1 day)            change_substorage_dict['slope%s'%(slope)].append(change_substorage)            change_suf = (total_surface_storage - Initial_Surf_Storage)              change_sufstorage_dict['slope%s'%(slope)].append(change_suf)            change_storage_actual['slope%s'%(slope)].append(change_suf+change_substorage)                else:                change_substorage = (total_sbs - sbs_t)               change_substorage_dict['slope%s'%(slope)].append(change_substorage)            change_suf = (total_surface_storage - surf_t)              change_sufstorage_dict['slope%s'%(slope)].append(change_suf)            change_storage_actual['slope%s'%(slope)].append(change_suf+change_substorage)            sbs_t = total_sbs    #reset the t-1 timestep variables        surf_t = total_surface_storage                #%%#Final WTD for each slopefor slope in range(len(simulations['slopex'])):    plt.imshow(wtd_dict['slope%s'%(slope)][4999], origin="lower", extent=(0, 310, 0, 50))    title = simulations['slopex'][slope]    plt.xlabel('x axis (m)')    plt.ylabel('y axis (m)')    plt.title('WTD_{}'.format(title))    cb = plt.colorbar()    cb.set_label('Water Table Depth (m)')    plt.show()        #plt.savefig('WTD_{}.png'.format(simulations['slope%s'%(slope)]))        #%%##wt at the top left of domain (0,0)left_corner = []for i in range(10000):    left_corner.append(wtd_dict['slope%s'%(2)][i][0,0])    plt.plot(left_corner[0:2000])#%%#average WTD for each         #plt.plot(X_Range_Long, average_wtd['slope0'], marker='.', markersize=4, label="wtd Slope 0.02")plt.title("Average WTD for slope 0.02, 0.05, 0.08")#plt.ylim((6.24, 6.26))plt.xlabel('Timestep (day)')plt.ylabel("wtd (m)")#plt.plot(X_Range_Long, average_wtd['slope1'], marker='.', markersize=4, label="wtd  Slope 0.05")#plt.plot(X_Range_Long, average_wtd['slope2'], marker='.', markersize=4, label="wtd  Slope 0.08")plt.plot(average_wtd['slope3'][0:1000],label="wtd  Slope 0.1")# plt.plot(X_Range_Long, average_wtd['slope4'], marker='.', markersize=4, label="wtd  Slope 0.15")# plt.legend(loc=(1.04,0.5))plt.show()    #%%colors = ['b', 'c', 'r', 'g']#plt.plot(X_Range_Long, Qin, marker='.', markersize=4, label="Qin")plt.plot(outflow_dict['slope0'][0:500], color = 'b', label="Outflow Slope 0.02")plt.plot(outflow_dict['slope1'][0:500], color = 'c',label="Outflow Slope 0.05")plt.plot(outflow_dict['slope2'][0:500], color = 'r', label="Outflow Slope 0.08")plt.plot(outflow_dict['slope3'][0:500], color = 'g', label="Outflow Slope 0.1")# plt.plot(X_Range_Long, outflow_dict['slope4'], marker='.', markersize=4, label="Outflow Slope 0.15")plt.legend(loc=(1.04,0.5))plt.xlabel('Timestep (1 day)')plt.ylabel('Magnitude')plt.title('Outflow for Various Hillslopes')plt.show()#plt.legend(loc="upper right")#plt.savefig('Outflow_Comparison.png')#%%plt.plot(groundwater_storage['slope0'][0:500], marker='.', markersize=4, label="GW Slope 0.02")plt.plot(groundwater_storage['slope1'][0:500], marker='.', markersize=4, label="GW Slope 0.05")plt.plot(groundwater_storage['slope2'][0:500], marker='.', markersize=4, label="GW Slope 0.08")plt.plot(groundwater_storage['slope3'][0:500], marker='.', markersize=4, label="GW Slope 0.1")# plt.plot(X_Range_Long, groundwater_storage['slope4'], marker='.', markersize=4, label="GW Slope 0.15")plt.xlabel('Timestep (1 day)')plt.ylabel('Magnitude (m3)')plt.title('Groundwater Storage')plt.legend(loc="upper right")plt.legend(loc=(1.04,0.5))plt.show()#plt.savefig('Groundwater_storage.png')#%%       colors = ['b', 'c', 'r', 'g']plt.plot(subsurface_storage['slope0'][0:500], color = 'b', label="Sub Slope 0.02")plt.plot(subsurface_storage['slope1'][0:500], color = 'c', label="Sub Slope 0.05")plt.plot(subsurface_storage['slope2'][0:500], color = 'r', label="Sub Slope 0.08")plt.plot(subsurface_storage['slope3'][0:500], color = 'g', label="Sub Slope 0.1")# plt.plot(X_Range_Long, subsurface_storage['slope4'], marker='.', markersize=4, label="GW Slope 0.15")plt.xlabel('Timestep (1 day)')plt.ylabel('Magnitude (m3)')plt.title('Subsurface Storage')# plt.legend(loc="upper right")plt.legend(loc=(1.04,0.5))plt.show()#%%plt.plot(surface_storage_dict['slope0'][0:500], marker='.', markersize=4, label="Surf Slope 0.02")plt.plot(surface_storage_dict['slope1'][0:500], marker='.', markersize=4, label="Surf Slope 0.05")plt.plot(surface_storage_dict['slope2'][0:500], marker='.', markersize=4, label="Surf Slope 0.08")plt.plot(surface_storage_dict['slope3'][0:500], marker='.', markersize=4, label="Surf Slope 0.1")# plt.plot(X_Range_Long, surface_storage_dict['slope4'], marker='.', markersize=4, label="GW Slope 0.15")plt.xlabel('Timestep (1 day)')plt.ylabel('Magnitude (m3)')plt.title('Surfacewater Storage')plt.legend(loc="upper right")plt.legend(loc=(1.04,0.5))plt.show()#plt.savefig('Surface_storage.png')    #%%###Water Balancey1 = Qin[0:500]  y2 = Qout_dict['slope0'][0:500] #y3 = delta_S_dict['slope0'][0:500] y4 = change_storage_actual['slope0'][0:500] plt.plot(y1, linestyle='-')plt.plot(y2, linestyle=':')plt.plot(y3, linestyle='--')plt.plot(y4, linestyle='-.')plt.title('Water Balance Slope 0.02')plt.xlabel('Time (days)')plt.ylabel('Volume (m^3)')#plt.ylim((-0.5, 0.5))#lengend of the 4 linesdash_line = mlines.Line2D([], [], linestyle='-', label='Influx')dot_line = mlines.Line2D([], [], color ='orange', linestyle=':', label='Outflux')doubledash_line = mlines.Line2D([], [], color = 'green', linestyle='--', label='Change in Storage (Qin-Qout)')dashdot_line = mlines.Line2D([], [], color = 'red', linestyle='-.', label='Change in Storage (Actual)')plt.legend(loc='lower right', handles=[dash_line, dot_line, doubledash_line, dashdot_line])plt.grid(True)plt.show()#plt.savefig('water_balance0.02.png')#%%y3 = delta_S_dict['slope0'][0:500] y4 = change_storage_actual['slope0'][0:500] plt.plot(y3, linestyle='--')plt.plot(y4, linestyle='-.')plt.show()#%%##see if qin and qout match as well as the change in storageprint("Qin", sum((Qin)))print("Qout", sum(Qout_dict['slope0']))print('detla_S', sum(delta_S_dict['slope0']))print('change_storage actual', sum(change_storage_actual['slope0']))total_initial_storage = surface_storage_dict['slope0'][0] + subsurface_storage['slope0'][0]total_final_storage = surface_storage_dict['slope0'][9999] + subsurface_storage['slope0'][9999]print(total_initial_storage - total_final_storage)##goodi#%%###Water Balancey1 = Qin[0:500]  y2 = Qout_dict['slope1'][0:500] #y3 = delta_S_dict['slope1'][0:500] y4 = change_storage_actual['slope1'][0:500] plt.plot(y1, linestyle='-')plt.plot(y2, linestyle=':')plt.plot(y3, linestyle='--')plt.plot(y4, linestyle='-.')plt.title('Water Balance Slope 0.05')plt.xlabel('Time (days)')plt.ylabel('Volume (m^3)')#plt.ylim((-0.5, 0.5))#lengend of the 4 linesdash_line = mlines.Line2D([], [], linestyle='-', label='Influx')dot_line = mlines.Line2D([], [], color ='orange', linestyle=':', label='Outflux')doubledash_line = mlines.Line2D([], [], color = 'green', linestyle='--', label='Change in Storage (Qin-Qout)')dashdot_line = mlines.Line2D([], [], color = 'red', linestyle='-.', label='Change in Storage (Actual)')plt.legend(loc='lower right', handles=[dash_line, dot_line, doubledash_line, dashdot_line])print(np.mean(Qin))print(np.mean(Qout_dict['slope1']))plt.grid(True)plt.show()#plt.savefig('water_balance0.05.png')#%%print("Qin", sum((Qin)[4000:]))print("Qout", sum(Qout_dict['slope1'][4000:]))print('detla_S', sum(delta_S_dict['slope1'][4000:]))print('change_storage actual', sum(change_storage_actual['slope1'][4000:]))#%%###Water Balancey1 = Qin  y2 = Qout_dict['slope2'] #y3 = delta_S_dict['slope2'] y4 = change_storage_actual['slope2'] plt.plot(X_Range_Long, y1, linestyle='-')plt.plot(X_Range_Long, y2, linestyle=':')plt.plot(X_Range_Long, y3, linestyle='--')plt.plot(X_Range_Long, y4, linestyle='-.')plt.title('Water Balance Slope 0.08')plt.xlabel('Time (days)')plt.ylabel('Volume (m^3)')#plt.ylim((-0.5, 0.5))#lengend of the 4 linesdash_line = mlines.Line2D([], [], linestyle='-', label='Influx')dot_line = mlines.Line2D([], [], color ='orange', linestyle=':', label='Outflux')doubledash_line = mlines.Line2D([], [], color = 'green', linestyle='--', label='Change in Storage (Qin-Qout)')dashdot_line = mlines.Line2D([], [], color = 'red', linestyle='-.', label='Change in Storage (Actual)')plt.legend(loc='lower right', handles=[dash_line, dot_line, doubledash_line, dashdot_line])plt.grid(True)plt.show()#plt.savefig('water_balance0.15.png')#%%print("Qin", sum(Qin))print("Qout", sum(Qout_dict['slope2']))print('detla_S', sum(delta_S_dict['slope2']))print('change_storage actual', sum(change_storage_actual['slope2']))#%%##variance of Qin and Qout for each slopevar_qin = statistics.variance(Qin, xbar=None)#print(var_qin)var_qout = statistics.variance(outflow_dict['slope0'])print(var_qin, var_qout)#%%### plot of layer_storage for one domain over timefor line in range(nz):    plt.plot(storage_layered['slope0']['layer%s'%(line)][0:500], label='layer%s'%(line))#plt.legend(loc=(1.15,0.0), prop={'size': 7.5})plt.title('Subsurface Storage by Domain Layer \nSlope 0.02')plt.ylabel('m3')plt.xlabel('timestep')plt.show()#plt.savefig('storagebylayer0.02.png')#%%### plot of layer_storage for one domain over timefor line in range(nz):    plt.plot(storage_layered['slope2']['layer%s'%(line)][0:500], label='layer%s'%(line))#plt.legend(loc=(1.15,0.0), prop={'size': 7.5})plt.title('Subsurface Storage by Domain Layer \nSlope 0.15')plt.ylabel('m3')plt.xlabel('timestep')plt.show()#plt.savefig('storagebylayer0.15.png')#%%##variance of each layer by tuples pairs (layer, variance)variance = {}for slope in range(len(simulations['slopex'])):    variance['slope%s'%(slope)] = []    for layer in range(nz):        variance['slope%s'%(slope)].append(tuple([layer, statistics.variance(storage_layered['slope%s'%(slope)]['layer%s'%(layer)])]))#%%for slope in range(len(simulations['slopex'])):    plt.plot(*zip(*variance['slope%s'%(slope)]), label='slope ' + str(simulations['slopex'][slope]))plt.xticks(np.arange(0, 100, 10)) plt.xlim(65,100)plt.xlabel('Layer')plt.ylabel('Variance')plt.title('Variance by Subsurface Layer \n(Bottom = 0 and Top = 50)')plt.legend()plt.show()#plt.savefig('variancebylayer.png')#%% #%%# #https://www.researchgate.net/post/How_to_correctly_implement_Welch_using_Python#%%##############7/2/20 plotsplt.plot(Qin[0:500])plt.ylabel('Qin (m3)')plt.xlabel('Timestep (day)')plt.title('Qin Time Series')plt.show()#%%#Real plots#input signal periodovertline = 0.008f, s = signal.periodogram(Qin)  # for welch  nfft = 16384) plt.figure()plt.loglog(f, s)plt.xlabel('freq (1/day)')plt.ylabel('PSD of Noise (Q^2/f) ')plt.title('Periodogram of Noise Input')ss = s[1:]ff = f[1:]coefficients = np.polyfit(np.log10(ff), np.log10(ss), 1)polynomial = np.poly1d(coefficients)log10_y_fit = polynomial(np.log10(ff))plt.plot(ff, 10**log10_y_fit, label="slope" + str(round(coefficients[0], 3)))# plt.axvline(x=0.01, color = 'r', alpha = 0.5, label = 'f = 0.002')# plt.axvline(x=0.02, color = 'g', alpha = 0.5, label = 'f = 0.005')# plt.axvline(x=0.1,  color = 'b', alpha = 0.5, label = 'f = 0.02')plt.ylim(10e-4, 10e5)plt.axvline(x=vertline)plt.legend()plt.show()#plt.savefig('noise_qin_periodo.png')#%%#relative power of the input frequencieslow = [0.008, 0.0196, 0.099]high = [0.012, 0.0204, 0.101]rel_pwr = 0ranger = np.asarray(high) - np.asarray(low)#low, high = [(0.0018, 0.0022), (0.0048, 0.0052), (0.0198, 0.0202)]#for slope in range(len(simulations['slopex'])):for i in range(len((low))):    f, s = signal.periodogram(Qin)     ss = s[1:]    ff = f[1:]    freq_res = ff[1] - ff[0]    idx_delta = np.logical_and(ff >= low[i], ff <= high[i])    delta_power = integrate.simps(ss[idx_delta], dx=freq_res)    total_power = integrate.simps(s, dx=freq_res)    delta_rel_power = delta_power / total_power    rel_pwr = rel_pwr + delta_rel_power    plt.loglog(ff, ss, lw=2, color='k')    plt.fill_between(ff, ss, where=idx_delta, color='skyblue')    plt.xlabel('Frequency (Hz)')    plt.ylabel('Power spectral density (Q^2 / Hz)')    plt.title("Periodogram Harmonics Input")    print(total_power, delta_rel_power, delta_power)plt.figtext(.6, .75, "Absolute power: {}\n Relative power: {} \n {}".format(round(total_power, 3), round(rel_pwr, 3), ranger))plt.show()#%%slopes = [0.02, 0.05, 0.08, 0.1]colors = ['b', 'c', 'r', 'g']vertline = 0.008for slope in range(len(simulations['slopex'])):    freq, spectra = signal.periodogram(outflow_dict['slope%s'%(slope)])    freq_masked = freq[80:]    spectra_masked = spectra[80:]    coefficients = np.polyfit(np.log10(freq_masked), np.log10(spectra_masked), 1)    polynomial = np.poly1d(coefficients)    log10_y_fit = polynomial(np.log10(freq_masked))    #plt.plot(freq_masked, 10**log10_y_fit, color = colors[slope], alpha = 0.7, ls = '-.' ) #label="{:02}".format(coefficients[0]))    plt.loglog(freq, spectra, color = colors[slope], label = str(slopes[slope]) + ': ' + "Beta=" + str(round(coefficients[0], 2)))    plt.ylim(10e-4, 10e4)    plt.ylabel('PSD Q^2/1/day')    plt.xlabel('Frequency 1/day')    plt.title("Periodogram of Qout Cutoff = {}".format(vertline))    plt.legend()plt.axvline(x=vertline)plt.show()#%%slopes = [0.02, 0.05, 0.08, 0.1]colors = ['b', 'c', 'r', 'g']vertline = 0.008for slope in range(len(simulations['slopex'])):    freq, spectra = signal.welch(outflow_dict['slope%s'%(slope)], nfft = 16384)    freq_masked = freq[80:]    spectra_masked = spectra[80:]    coefficients = np.polyfit(np.log10(freq_masked), np.log10(spectra_masked), 1)    polynomial = np.poly1d(coefficients)    log10_y_fit = polynomial(np.log10(freq_masked))    #plt.plot(freq_masked, 10**log10_y_fit, color = colors[slope], alpha = 0.7, ls = '-.' ) #label="{:02}".format(coefficients[0]))    plt.loglog(freq, spectra, color = colors[slope], label = str(slopes[slope]) + ': ' + "Beta=" + str(round(coefficients[0], 2)))    plt.ylim(10e-4, 10e4)    plt.ylabel('PSD Q^2/1/day')    plt.xlabel('Frequency 1/day')    plt.title("Periodogram of Qout Cutoff = {}".format(vertline))    plt.legend()plt.axvline(x=vertline)plt.show()#%%## rel power of the various qouts##  for loop of beta slopeslopes = [0.02, 0.05, 0.08, 0.1]colors = ['b', 'c', 'r', 'g']vertline = 0.008for slope in range(len(simulations['slopex'])):    vertline = 0.008    freq, spectra = signal.periodogram(outflow_dict['slope%s'%(slope)])    freq_masked = freq[80:]    spectra_masked = spectra[80:]    coefficients = np.polyfit(np.log10(freq_masked), np.log10(spectra_masked), 1)    polynomial = np.poly1d(coefficients)    log10_y_fit = polynomial(np.log10(freq_masked))    plt.plot(freq_masked, 10**log10_y_fit, color = 'k', alpha = 0.7, ls = '-.' ) #label="{:02}".format(coefficients[0]))    plt.loglog(freq, spectra, color = colors[slope], label = str(slopes[slope]) + ': ' + "Beta=" + str(round(coefficients[0], 2)))    plt.ylim(10e-3, 10e6)    plt.ylabel('PSD Q^2/1/day')    plt.xlabel('Frequency 1/day')    plt.title("Periodogram of Qout and Rel Power")    plt.legend()    plt.axvline(x=vertline)    plt.show()    plt.savefig('harmonic_qout_beta{}.png'.format(slope))    #%%## rel power of the various qouts## for loop of power     #relative power of the input frequencieslow = [0.008, 0.0196, 0.099]high = [0.012, 0.0204, 0.101]rel_pwr = 0for i in range(len((low))):    f, s = signal.periodogram(outflow_dict['slope3'])     ss = s[1:]    ff = f[1:]    freq_res = ff[1] - ff[0]    idx_delta = np.logical_and(ff >= low[i], ff <= high[i])    delta_power = integrate.simps(ss[idx_delta], dx=freq_res)    total_power = integrate.simps(s, dx=freq_res)    delta_rel_power = delta_power / total_power    rel_pwr = rel_pwr + delta_rel_power    plt.loglog(ff, ss, lw=2, color='k')    plt.fill_between(ff, ss, where=idx_delta, color='skyblue')    plt.xlabel('Frequency (Hz)')    plt.ylabel('Power spectral density (Q^2 / Hz)')    plt.title("Periodogram Harmonics Input Slope: 0.02")    print(total_power, delta_rel_power, delta_power)plt.figtext(.6, .8, "Absolute power: {}\n Relative power: {}".format(round(total_power, 3), round(rel_pwr, 3)))plt.show() plt.savefig('harmonic_qout_relpower0.1.png')                   # low = [0.008, 0.0196, 0.099]# high = [0.012, 0.0204, 0.101]# slopes = [0.02, 0.05, 0.08, 0.1]# colors = ['b', 'c', 'r', 'g']# vertline = 0.008# rel_pwr = 0# for slope in range(len(simulations['slopex'])):#     for i in range(len((low))):#         freq, spectra = signal.periodogram(outflow_dict['slope%s'%(slope)])#         ss = s[1:]#         ff = f[1:]#         freq_res = ff[1] - ff[0]#         idx_delta = np.logical_and(ff >= low[i], ff <= high[i])#         delta_power = integrate.simps(ss[idx_delta], dx=freq_res)#         total_power = integrate.simps(s, dx=freq_res)#         delta_rel_power = delta_power / total_power#         rel_pwr = rel_pwr + delta_rel_power#         #plt.loglog(ff, ss, lw=2, color='k')#         plt.fill_between(ff, ss, where=idx_delta, color='skyblue')#     freq_masked = freq[80:]#     spectra_masked = spectra[80:]#     coefficients = np.polyfit(np.log10(freq_masked), np.log10(spectra_masked), 1)#     polynomial = np.poly1d(coefficients)#     log10_y_fit = polynomial(np.log10(freq_masked))#     plt.plot(freq_masked, 10**log10_y_fit, color = 'k', alpha = 0.7, ls = '-.' ) #label="{:02}".format(coefficients[0]))#     plt.loglog(freq, spectra, color = colors[slope], label = str(slopes[slope]) + ': ' + "Beta=" + str(round(coefficients[0], 2)))#     plt.ylim(10e-3, 10e6)#     plt.ylabel('PSD Q^2/1/day')#     plt.xlabel('Frequency 1/day')#     plt.title("Periodogram of Qout and Rel Power")#     plt.legend()#     plt.axvline(x=vertline)#     plt.figtext(.6, .75, "Absolute power: {}\n Relative power: {}".format(round(total_power, 3), round(rel_pwr, 3)))#     plt.show()#     rel_power = 0#     #plt.savefig('harmonic_qout_beta{}.png'.format(slope))    #%%slopes = [0.02, 0.05, 0.08, 0.1]colors = ['b', 'c', 'r', 'g']vertline = 0.008for slope in range(len(simulations['slopex'])):    freq, spectra = signal.periodogram(surface_storage_dict['slope%s'%(slope)])    freq_masked = freq[80:]    spectra_masked = spectra[80:]    coefficients = np.polyfit(np.log10(freq_masked), np.log10(spectra_masked), 1)    polynomial = np.poly1d(coefficients)    log10_y_fit = polynomial(np.log10(freq_masked))    #plt.plot(freq_masked, 10**log10_y_fit, color = colors[slope], alpha = 0.7, ls = '-.' ) #label="{:02}".format(coefficients[0]))    plt.loglog(freq, spectra, color = colors[slope], label = str(slopes[slope]) + ': ' + "Beta=" + str(round(coefficients[0], 2)))    plt.ylim(10e-7, 10e5)    plt.ylabel('PSD Q^2/1/day')    plt.xlabel('Frequency 1/day')    plt.title("Periodogram of Surface Storage: Cutoff = {}".format(vertline))    plt.legend()plt.axvline(x=vertline)plt.show()#plt.savefig("harmonic_surface_periodo_beta")#%%slopes = [0.02, 0.05, 0.08, 0.1]colors = ['b', 'c', 'r', 'g']vertline = 0.008for slope in range(len(simulations['slopex'])):    freq, spectra = signal.periodogram(subsurface_storage['slope%s'%(slope)])    freq_masked = freq[80:]    spectra_masked = spectra[80:]    coefficients = np.polyfit(np.log10(freq_masked), np.log10(spectra_masked), 1)    polynomial = np.poly1d(coefficients)    log10_y_fit = polynomial(np.log10(freq_masked))    #plt.plot(freq_masked, 10**log10_y_fit, color = colors[slope], alpha = 0.7, ls = '-.' ) #label="{:02}".format(coefficients[0]))    plt.loglog(freq, spectra, color = colors[slope], label = str(slopes[slope]) + ': ' + "Beta=" + str(round(coefficients[0], 2)))    plt.ylim(10e-2, 10e8)    plt.ylabel('PSD Q^2/1/day')    plt.xlabel('Frequency 1/day')    plt.title("Periodogram of Subsurface Storage: Cutoff = {}".format(vertline))    plt.legend()plt.axvline(x=vertline)plt.show()#plt.savefig("harmonic_subsurfface_periodo_beta")#%%#%%slopes = [0.02, 0.05, 0.08, 0.1]colors = ['b', 'c', 'r', 'g']vertline = 0.008for slope in range(len(simulations['slopex'])):    freq, spectra = signal.periodogram(subsurface_storage['slope%s'%(slope)])    freq_masked = freq[80:]    spectra_masked = spectra[80:]    coefficients = np.polyfit(np.log10(freq_masked), np.log10(spectra_masked), 1)    polynomial = np.poly1d(coefficients)    log10_y_fit = polynomial(np.log10(freq_masked))    #plt.plot(freq_masked, 10**log10_y_fit, color = colors[slope], alpha = 0.7, ls = '-.' ) #label="{:02}".format(coefficients[0]))    plt.loglog(freq, spectra, color = colors[slope], label = str(slopes[slope]) + ': ' + "Beta=" + str(round(coefficients[0], 2)))    plt.ylim(10e-2, 10e7)    plt.ylabel('PSD Q^2/1/day')    plt.xlabel('Frequency 1/day')    plt.title("Periodogram of Subsurface Storage Cutoff = {}".format(vertline))    plt.legend()plt.axvline(x=vertline)plt.show()#%%slopes = [0.02, 0.05, 0.08, 0.1]colors = ['b', 'c', 'r', 'g']vertline = 0.008for slope in range(len(simulations['slopex'])):    freq, spectra = signal.welch(subsurface_storage['slope%s'%(slope)], nfft = 16384)    freq_masked = freq[80:]    spectra_masked = spectra[80:]    coefficients = np.polyfit(np.log10(freq_masked), np.log10(spectra_masked), 1)    polynomial = np.poly1d(coefficients)    log10_y_fit = polynomial(np.log10(freq_masked))    #plt.plot(freq_masked, 10**log10_y_fit, color = colors[slope], alpha = 0.7, ls = '-.' ) #label="{:02}".format(coefficients[0]))    plt.loglog(freq, spectra, color = colors[slope], label = str(slopes[slope]) + ': ' + "Beta=" + str(round(coefficients[0], 2)))    plt.ylim(10e-2, 10e7)    plt.ylabel('PSD Q^2/1/day')    plt.xlabel('Frequency 1/day')    plt.title("Periodogram of Subsurface Storage  Cutoff = {}".format(vertline))    plt.legend()plt.axvline(x=vertline)plt.show()